from datetime import datetime, timedelta
import numpy as np
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt


df_holdings = pd.read_csv("holdings.csv")
df_trans = pd.read_csv("transactions.csv")


class TimeFrame:
    
    ''' Most abstract object'''

    def __init__ (self, 
                  startday:str, 
                  endday:str
                  ):
        
        #days as str
        self.startday_str = startday #string
        self.endday_str = endday #string
        #days as datetime
        self.startday_dt = datetime.strptime(startday, '%Y-%m-%d') #DateTime object YYYY-MM-DD 00:00:00
        self.endday_dt = datetime.strptime(endday, '%Y-%m-%d') #DateTime object YYYY-MM-DD 00:00:00
        
        self.list_days_dt = self._list_days() #a list of all the days in the Time period
        self.list_days_str = self._list_days(as_str = True)
        self.numdays = len(self.list_days_str)

        #populated with portfolio data
        self.portfolios = list()
        self.transaction_date = dict()
        self.transactions_df = dict() 
        self.init_holdings_port = dict()
        self.numport = 0
        self.IndividualDays_instances = dict() #generates a dictionary with all the individual days as keys and the object as values

    def _list_days(self, as_str:bool = False):
        days = []
        current_date = self.startday_dt
        
        while current_date <= self.endday_dt:
            if as_str:
                days.append(current_date.strftime('%Y-%m-%d'))
            else:
                days.append(current_date)
            current_date += timedelta(days=1)        
        return days
    
    def genportfolio(self, holdings_df:pd.DataFrame, transactions_df:pd.DataFrame, name:str):
        ''' To generate one individual portfolio without creating the instances but rather the metadata in TP class object'''
        self.portfolios.append(name)
        self.transaction_date[name] = transactions_df["Date"].tolist()
        self.transactions_df[name] = transactions_df.copy(deep=True)
        self.init_holdings_port[name] = holdings_df.copy(deep=True) 
        self.numport += 1

    def gendays(self):
        '''Execute once all the portfolios are generated by the user'''
        for day in self.list_days_str:
            _start_day_bool = True if day == self.startday_str else False
            _temp_instance = IndividualDay(self, #here we are passing the instance of TS to each ID so that it can work with it
                                            day, 
                                            self.portfolios, 
                                            self.transaction_date, 
                                            self.init_holdings_port, 
                                            self.transactions_df, 
                                            is_start_day = _start_day_bool)
            self.IndividualDays_instances[day] = _temp_instance

    def performance(self):
        ''' calculates performace '''
        self.performance_dict = dict() #a dictionary of dictionaries
        self.nav_dict = dict()
        for port in self.portfolios:
            self.performance_dict[port] = dict()
            self.nav_dict[port] = dict()
            for day in self.IndividualDays_instances.keys():
                    #retrieve the values of the valuations
                _valuation = self.IndividualDays_instances[day].portfolio_instances[port].valuation
                _nav = self.IndividualDays_instances[day].portfolio_instances[port].nav
                _package = {day:_valuation}
                _package_nav = {day:_nav}
                self.performance_dict[port].update(_package)
                self.nav_dict[port].update(_package_nav)

        self.port_val_df = pd.DataFrame(self.performance_dict).dropna()
        self.nav_df = pd.DataFrame(self.nav_dict).dropna()
        
        self.returns_df = pd.DataFrame(self.performance_dict).dropna().pct_change() #to be depreciated and use NAV instead
        self.nav_returns_df = pd.DataFrame(self.nav_dict).dropna().pct_change()
        

        print(self.returns_df.dropna())
        print(self.nav_returns_df.dropna())
        print(self.nav_df)
        self.returns_df.plot()
        self.nav_returns_df.plot()
        self.nav_df.plot()

        plt.show()



            

class IndividualDay(TimeFrame):
    ''' This object maps an individual day'''
    def __init__(self, instance, day:str, portfolios:list, transaction_date:dict, init_holdings_port:dict, transactions_df:dict, is_start_day:bool):
        
        self.day_str = day
        self.parent_instance = instance
        self.day_dt = datetime.strptime(day, '%Y-%m-%d')
        self.is_start_day = is_start_day #bool that tells us if it is the first day of the portfolios
        
        self.day_week = self.day_dt.weekday()
        self.is_weekday = True if self.day_week < 5 else False
        self.portfolios_list = portfolios #list of ports
        self.num_portfolio = 0
        self.transaction_date = transaction_date
        self.init_holding_port = init_holdings_port
        self.transaction_df = transactions_df

        self.portfolio_instances = dict()
        self.create_portfolio() #this should be executed last


    def create_portfolio(self):
        ''' This creates an instance of a portfolio'''
        for port in self.portfolios_list:
            trans = True if self.day_str in self.transaction_date[port] else False #bool that tells us if it is a transaction date
            self.portfolio_instances[port] = Portfolio(self, #here we are passing the instance of ID to the portfolio so that it can work with it
                                                       self.parent_instance, #here we are passing the instance of the TS
                                                       port, 
                                                       val_day=self.day_str,
                                                       is_trans_day=trans,
                                                       init_holdings = self.init_holding_port[port],
                                                       transactions = self.transaction_df[port],
                                                       is_start_day = self.is_start_day)
            self.num_portfolio += 1







class Portfolio(IndividualDay):
    
    ''' This modules a portfolio on a SPECIFIC day'''
    
    def __init__(self, instance_ID, instance_TS, name:str, val_day:str, is_trans_day:bool, init_holdings:pd.DataFrame, transactions:pd.DataFrame, is_start_day:bool, is_SAA:bool = False):
        
        #admin
        self.name = name
        self.parent_instance_ID = instance_ID
        self.parent_instance_TS = instance_TS
        self.val_day_str = val_day
        self.val_day_dt = datetime.strptime(val_day, '%Y-%m-%d')
        self.prev_day_dt = self.val_day_dt - timedelta(days = 1)
        self.prev_day_str = self.prev_day_dt.strftime("%Y-%m-%d")
        self.shares = 1000
        self.nav = np.nan
        self.is_SAA = is_SAA

        #holdings
        self.is_start_day = is_start_day
        self.init_holdings = init_holdings.copy(deep = True)
        self.prev_day_holdings = pd.DataFrame()
        self.adjusted_holdings = pd.DataFrame() # this data frame will hold the holdings adjusted for transactions
        self.priced_df = pd.DataFrame() #this will hold our final valuation df

        #transactions
        self.is_trans_day = is_trans_day
        self.transactions = transactions
        #valuation
        self.price_df = pd.DataFrame()
        self.valuation = None
        
        self._fetch_holdings() #adjust previous df
        self._adjustholdings() #adjust holdings for transactions
        self.priceit()




    def _fetch_holdings(self):
        ''' This funcition will fetch the previous days holdings or if init day fetch init holdings'''
        print(f"fetching the previous day holings for: {self.name} on date: {self.val_day_str}")
        if self.is_start_day:
            self.prev_day_holdings = self.init_holdings
        else:
            print(self.parent_instance_TS.IndividualDays_instances[self.prev_day_str].portfolio_instances)
            self.prev_day_holdings = self.parent_instance_TS.IndividualDays_instances[self.prev_day_str].portfolio_instances[self.name].adjusted_holdings
            self.yesterdays_units = self.parent_instance_TS.IndividualDays_instances[self.prev_day_str].portfolio_instances[self.name].shares
            self.yesterdays_nav = self.parent_instance_TS.IndividualDays_instances[self.prev_day_str].portfolio_instances[self.name].nav
        print(f"printing previous day holdings. For day: {self.prev_day_str} and port: {self.name}")
        print(self.prev_day_holdings)

    def _adjustholdings(self):
        if self.is_trans_day:
                ''' Adjustment made to holdings incase of transactions'''
                print(f"Adjusting the holdings for:{self.name}")
                working_df_trans = self.transactions.copy()
                working_df_holdings = self.prev_day_holdings
                working_df_trans["total"] = working_df_trans["Quantity"] * working_df_trans["Price"]  #takes care of affect on cash
                delta_cash = working_df_trans["total"].sum()

            
                for row in working_df_trans.itertuples():
                # Check if the Ticker exists in the holdings DataFrame
                    if row.Ticker in working_df_holdings['Ticker'].values:
                        # If it exists, update the quantity
                        working_df_holdings.loc[working_df_holdings["Ticker"] == row.Ticker, "Quantity"] += row.Quantity
                    else:
                        # If it doesn't exist, add a new row with the Ticker and Quantity
                        new_row = {'Ticker': row.Ticker, 'Quantity': row.Quantity}
                        working_df_holdings = working_df_holdings.append(new_row, ignore_index=True)
        
                #overwritting adjusting cash position  and holdings again
                working_df_holdings.loc[working_df_holdings["Ticker"] == "EUR", "Quantity"] = float(working_df_holdings.loc[working_df_holdings["Ticker"] == "EUR", "Quantity"]) + float(-delta_cash) #currently EUR cash is hardcoded in
                self.adjusted_holdings = working_df_holdings

        else:
            #when no need to adjust cuz no transactions
            self.adjusted_holdings = self.prev_day_holdings
        
    def pricing_df(self):
        '''Creates a df that gets priced'''
        tickers_to_query = pd.concat([self.adjusted_holdings["Ticker"], self.transactions["Ticker"]]).drop_duplicates() #incase we buy stocks that are not in our initial holdings we must concat and drop duplicates
        tickers_to_query_series = tickers_to_query[tickers_to_query != "EUR"].copy() #drops the CASH component
        tickers_to_query = tickers_to_query_series.astype(str).str.cat(sep=" ") #makes it useable my yahoo finance
        df = yf.download(tickers = tickers_to_query,
                    start = self.val_day_str,
                    progress = False)
        df = df["Adj Close"]
        df.index = df.index.strftime('%Y-%m-%d')
        print(df)
        #query industry data
        industries = dict()
        for ticker in tickers_to_query_series.tolist():
            ticker_object = yf.Ticker(ticker)
            ind_sector = ticker_object.info.get("sector", "other")
            industries[ticker] = ind_sector

        # Create a DataFrame where each row is a ticker and sector
        sector_df = pd.DataFrame(list(industries.items()), columns=["Ticker", "Sector"])
    
        return sector_df, df
            
    def priceit(self):
        
        '''This function will take a Dataframe with pricing and merge it to the holdings data frame. The adjustments df has to be ran before hand or else there could be holdings that do not get priced '''
        _false_valuation = False
        working_sector_df, working_price_df = self.pricing_df()
        working_holdings_df = self.adjusted_holdings
        
        for row in working_holdings_df.itertuples():
            if row.Ticker != "EUR": #we will never get a price for cash component
                try:
                    # Attempt to update the 'Price' column
                    working_holdings_df.loc[working_holdings_df["Ticker"] == row.Ticker, "Price"] = working_price_df.loc[self.val_day_str, row.Ticker]
                except KeyError:
                    # Handle the case where the ticker or index is not found
                    print(f"Ticker {row.Ticker} not found in working_price_df or issue in updating.")
                    _false_valuation = True
                    self.valuation = np.nan
                    try:
                        working_holdings_df.loc[working_holdings_df["Ticker"] == row.Ticker, "Price"] = np.nan 
                    except:
                        print("Could not overwrite df")
                        continue
                    continue  # Continue to the next iteration
        working_holdings_df.loc[working_holdings_df["Ticker"] == "EUR", "Price"] = 1
        working_holdings_df["Total"] = working_holdings_df["Quantity"] * working_holdings_df["Price"]
        if _false_valuation:
            self.valuation = np.nan

        else:

            try:
                _valuation = working_holdings_df["Total"].sum()
                self.valuation = round(_valuation,4)
                working_holdings_df["Weight"] = working_holdings_df["Total"] / self.valuation
            except:
                self.valuation = np.nan 
        merged_df = working_holdings_df.merge(working_sector_df, on="Ticker", how="left")
        merged_df.loc[merged_df["Ticker"] == "EUR", "Sector"] = "CASH"
        self.priced_df = working_holdings_df
        #after we value it we must adjust for our 
        if self.is_SAA and isinstance(self.valuation, float):
            pass
            #some code to adjust the units on issue
        elif isinstance(self.valuation, float):
            self.nav = self.valuation / self.shares
            print(f"PRINTING NAV: {self.nav}") 


    


def test_TimeFrame(user_input):
    attributes = dir(user_input)
    attributes = [attr for attr in attributes if not attr.startswith('__')]
    for attr in attributes:
        value = getattr(user_input, attr)
        print(f"{attr}: {value}")


TS = TimeFrame('2024-01-01','2024-06-30')
TS.genportfolio(df_holdings,df_trans, "EQTY")
TS.genportfolio(df_holdings,df_trans, "FRG EQTY")
TS.gendays()
TS.performance()

