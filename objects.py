from datetime import datetime, timedelta
import numpy as np
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import logging


logging.basicConfig(
    level = logging.INFO,
    format = "%(asctime)s - %(levelname)s - %(message)s",
    handlers = [logging.FileHandler("app.log"), logging.StreamHandler()]
)




df_holdings = pd.read_csv("holdings.csv")
df_trans = pd.read_csv("transactions.csv")


class TimeFrame:
    
    ''' Most abstract object'''
    logging.info("We are initiating an instance of a TimeFrame")
    def __init__ (self, 
                  startday:str, 
                  endday:str
                  ):
        
        #days as str
        self.startday_str = startday #string
        self.endday_str = endday #string
        #days as datetime
        self.startday_dt = datetime.strptime(startday, '%Y-%m-%d') #DateTime object YYYY-MM-DD 00:00:00
        self.endday_dt = datetime.strptime(endday, '%Y-%m-%d') #DateTime object YYYY-MM-DD 00:00:00
        
        self.list_days_dt = self._list_days() #a list of all the days in the Time period
        self.list_days_str = self._list_days(as_str = True)
        self.numdays = len(self.list_days_str)

        #populated with portfolio data storage
        self.portfolios = list()
        self.transaction_date = dict()
        self.transactions_df_storage = dict() 
        self.init_holdings_port = dict()
        self.numport = 0
        self.IndividualDays_instances = dict() #generates a dictionary with all the individual days as keys and the object as values

    def _list_days(self, as_str:bool = False):
        '''self explanatory'''
        days = []
        current_date = self.startday_dt
        
        while current_date <= self.endday_dt:
            if as_str:
                days.append(current_date.strftime('%Y-%m-%d'))
            else:
                days.append(current_date)
            current_date += timedelta(days=1)        
        return days
    
    def genportfolio(self, holdings_df:pd.DataFrame, transactions_df:pd.DataFrame, name:str):
        ''' To generate one individual portfolio without creating the instances but rather the metadata in TP class object'''
        self.portfolios.append(name)
        self.transaction_date[name] = transactions_df["Date"].tolist()
        self.transactions_df_storage[name] = transactions_df.copy(deep=True)
        self.init_holdings_port[name] = holdings_df.copy(deep=True) 
        self.numport += 1

    def gendays(self):
        '''Execute once all the portfolios are generated by the user'''
        for day in self.list_days_str:
            _start_day_bool = True if day == self.startday_str else False
            _temp_instance = IndividualDay(self, #here we are passing the instance of TS to each ID so that it can work with it
                                            day, 
                                            self.portfolios, 
                                            self.transaction_date, 
                                            self.init_holdings_port, 
                                            self.transactions_df_storage, 
                                            is_start_day = _start_day_bool)
            self.IndividualDays_instances[day] = _temp_instance

    def performance(self):
        ''' calculates performace '''
        self.performance_dict = dict() #a dictionary of dictionaries
        self.nav_dict = dict()
        for port in self.portfolios:
            self.performance_dict[port] = dict()
            self.nav_dict[port] = dict()
            for day in self.IndividualDays_instances.keys():
                    #retrieve the values of the valuations
                _valuation = self.IndividualDays_instances[day].portfolio_instances[port].valuation
                _nav = self.IndividualDays_instances[day].portfolio_instances[port].nav
                _package = {day:_valuation}
                _package_nav = {day:_nav}
                self.performance_dict[port].update(_package)
                self.nav_dict[port].update(_package_nav)

        self.port_val_df = pd.DataFrame(self.performance_dict).dropna()
        self.nav_df = pd.DataFrame(self.nav_dict).dropna()
        
        self.returns_df = pd.DataFrame(self.performance_dict).dropna().pct_change() #to be depreciated and use NAV instead
        self.nav_returns_df = pd.DataFrame(self.nav_dict).dropna().pct_change()
        
        self.returns_df.plot(title="returns valuation non adjusted")
        self.nav_returns_df.plot(title="Portfolio returns")
        self.nav_df.plot(title="Portfolio NAV")
        self.port_val_df.plot(title = "AUM")

        plt.show()

            

class IndividualDay(TimeFrame):
    ''' This object maps an individual day'''
    def __init__(self, instance, day:str, portfolios:list, transaction_date:dict, init_holdings_port:dict, transactions_df_storage:dict, is_start_day:bool):
        
        logging.info(f"We are generating an instance of an Individual day. The day is: {day}")

        self.day_str = day
        self.parent_instance = instance #TS objects
        self.day_dt = datetime.strptime(day, '%Y-%m-%d')
        self.is_start_day = is_start_day #bool that tells us if it is the first day of the portfolios
        
        self.day_week = self.day_dt.weekday()
        self.is_weekday = True if self.day_week < 5 else False
        self.portfolios_list = portfolios #list of ports
        self.num_portfolio = 0
        self.transaction_date = transaction_date
        self.init_holding_port = init_holdings_port
        self.transactions_df_storage = transactions_df_storage

        self.portfolio_instances = dict()
        self.create_portfolio() #this should be executed last
        


    def create_portfolio(self):
        ''' This creates an instance of a portfolio'''
        for port in self.portfolios_list:
            trans = True if self.day_str in self.transaction_date[port] else False #bool that tells us if it is a transaction date
            is_SAA = True if ((self.transactions_df_storage[port]['Date'] == self.day_str) & (self.transactions_df_storage[port]['Ticker'] == "EUR")).any() else False
            self.portfolio_instances[port] = Portfolio(self, #here we are passing the instance of ID to the portfolio so that it can work with it
                                                       self.parent_instance, #here we are passing the instance of the TS
                                                       port, 
                                                       val_day=self.day_str,
                                                       is_trans_day=trans,
                                                       init_holdings = self.init_holding_port[port],
                                                       transactions_df = self.transactions_df_storage[port],
                                                       is_start_day = self.is_start_day,
                                                       is_SAA = is_SAA)
            self.num_portfolio += 1





class Portfolio(IndividualDay):
    
    ''' This modules a portfolio on a SPECIFIC day'''
    
    def __init__(self, instance_ID, instance_TS, name:str, val_day:str, is_trans_day:bool, init_holdings:pd.DataFrame, transactions_df:pd.DataFrame, is_start_day:bool, is_SAA:bool = False):
        
        logging.info(f"We are generating a instance of a Portfolio for a specific day. The portfolio is: {name} for day: {val_day}")
        
        #admin
        self.name = name
        self.parent_instance_ID = instance_ID
        self.parent_instance_TS = instance_TS
        self.val_day_str = val_day
        self.val_day_dt = datetime.strptime(val_day, '%Y-%m-%d')
        self.prev_day_dt = self.val_day_dt - timedelta(days = 1)
        self.prev_day_str = self.prev_day_dt.strftime("%Y-%m-%d")
        self.tomorrow_dt = self.val_day_dt + timedelta(days = 1)
        self.tomorrow_dt_str = self.tomorrow_dt.strftime("%Y-%m-%d")
        self.shares = np.nan
        self.nav = np.nan
        self.is_SAA = is_SAA
        self.is_TAA = is_trans_day
        self.is_start_day = is_start_day

        #dataframes
        self.init_holdings = init_holdings.copy(deep = True)
        self.transactions_df = transactions_df #df

        self.prev_day_holdings_df = pd.DataFrame()
        self.final_holdings_df = pd.DataFrame() # this data frame will hold the holdings adjusted for transactions
        self.priced_df = pd.DataFrame() #this will hold our prices
        self.merged_df = pd.DataFrame() #this will hold the final value df
        self.valuation = None
        
        self._generate_holdings() #fetches the holdings from the previous day
        self._generate_pricing()

    def _generate_holdings(self):
        ''' This functions purpose is to generate two dataframes. The first one will create the holdings of the previous day (or initial holdings) 
            this data frame will then be adjusted in the case of TAA or SAA and we will end with the final holdings dataframe '''
        
        logging.info("We are generating the two holding data frames for this portfolio")
        
        if self.is_start_day:
            ''' in the case of start day the previous day holdings will just be our initial holdings'''
            logging.info("Today is start day")
            self.prev_day_holdings_df = self.init_holdings
            logging.info("Our previous day holdings (in this case init):")
            logging.info(f"\n{self.prev_day_holdings_df}")           
        else:
            '''in this case we are getting our TS instance and finding the final holdings for yesterday and those will be todays begining holdings'''
            self.prev_day_holdings_df = self.parent_instance_TS.IndividualDays_instances[self.prev_day_str].portfolio_instances[self.name].final_holdings_df
            self.final_holdings_df = self.prev_day_holdings_df #will get overwritten if there is a AA or TAA
            logging.info("Our previous day holding df:")
            logging.info(f"\n{self.prev_day_holdings_df}")

        if self.is_SAA or self.is_TAA:
            ''' If there is an asset allocation we must adjust our holdings and CASH to show that'''
            working_prev_day_holdings_df = self.prev_day_holdings_df.copy(deep = True) #our previous day holdings
            working_transactions_df = self.transactions_df.copy(deep = True) #The transactions for our portfolio
            
            if self.is_SAA:
                ''' Here we must only adjust cash'''
                logging.info("Today is SAA day")
                SAA_amount = (working_transactions_df.loc[(working_transactions_df["Ticker"] == "EUR") & (working_transactions_df["Date"] == self.val_day_str), "Quantity"]).sum()
                logging.info(f"Our SAA amount is:{SAA_amount}")
                working_prev_day_holdings_df.loc[working_prev_day_holdings_df["Ticker"] == "EUR", "Quantity"] = working_prev_day_holdings_df.loc[working_prev_day_holdings_df["Ticker"] == "EUR", "Quantity"] + SAA_amount
                final_df = working_prev_day_holdings_df #will get overwritten if there is TAA for the TAA adjustments
                logging.info(f"Our final data frame after SAA adjustments")
                logging.info(f"\n{final_df}")
            
            if self.is_TAA:
                '''Here we must adjust cash and holdings'''
                logging.info("Today is TAA day")
                logging.info(working_transactions_df)
                TAA_moves_df = working_transactions_df[(working_transactions_df["Date"] == self.val_day_str) & (working_transactions_df["Ticker"] != "EUR")] #wont have the cash line
                TAA_amount = (TAA_moves_df["Quantity"] * TAA_moves_df["Price"]).sum()
                logging.info(f"Our TAA moves have a total cash impact of {TAA_amount}")
                logging.info("Our TAA moves are:")
                logging.info(f"\n{TAA_moves_df}")
                
                result = pd.merge(working_prev_day_holdings_df, TAA_moves_df, on="Ticker", how="outer", suffixes=("_holdings", "_pending")) #if SAA then working prev day holdings already has the adjustment
                result.fillna(0, inplace=True)
                
                logging.info(f"Our merged prev day holdings and pensing transactions are:")
                logging.info(f"\n{result}")
                
                result["Quantity"] = result[["Quantity_holdings", "Quantity_pending"]].sum(axis=1, skipna=True) #adjust the holdings for transactions
                final_df = result[["Ticker","Quantity"]]
                final_df.loc[final_df["Ticker"] == "EUR", "Quantity"] = final_df.loc[final_df["Ticker"] == "EUR", "Quantity"] - TAA_amount
                final_df = final_df.groupby('Ticker', as_index=False)['Quantity'].sum()
                logging.info("Our TAA adjusted df is (SAA adjustments also taken into consideration):")
                logging.info(f"\n{final_df}")
            
            self.final_holdings_df = final_df
            logging.info(f"Our final df after SAA and TAA adjustments:")
            logging.info(f"\n{self.final_holdings_df}")

    def _generate_pricing(self):
        '''This function generates two data frames a priced df and a merged df'''
        Tickers_query = self.final_holdings_df["Ticker"].tolist() #takes the df we calculated in the previous step 
        Tickers_query.remove("EUR")
        results = {}
        for ticker in Tickers_query:
            try:
                price = yf.download(ticker,start = self.val_day_str, end = self.tomorrow_dt_str)
                stock = yf.Ticker(ticker)
                sector = stock.info.get('sector', 'N/A')
                logging.info(f"Historical price:{price} , sector: {sector}")
            except:
                continue


    


def test_TimeFrame(user_input):
    attributes = dir(user_input)
    attributes = [attr for attr in attributes if not attr.startswith('__')]
    for attr in attributes:
        value = getattr(user_input, attr)
        print(f"{attr}: {value}")


TS = TimeFrame('2024-01-01','2024-01-02')
TS.genportfolio(df_holdings,df_trans, "EQTY")
#TS.genportfolio(df_holdings,df_trans, "FRG EQTY")
TS.gendays()

logging.info("START")
price = yf.download("MAP.MC",start = "2024-01-10", end= "2024-01-11")
adj_close_value = price.loc["2024-01-10", 'Adj Close']
logging.info(f"\n{adj_close_value}")
logging.info("DONE")
